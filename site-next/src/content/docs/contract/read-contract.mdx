---
title: Reading Contracts
description: Read data from smart contracts using view and pure functions
---


Read data from smart contracts using view and pure functions. These calls don't require gas since they don't modify state.

### Basic Usage

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import (
    "github.com/ethereum/go-ethereum/common"
    "github.com/ChefBingbong/viem-go/client"
)

result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      common.HexToAddress("0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2"),
    ABI:          \`[{"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}]}]\`,
    FunctionName: "totalSupply",
})
if err != nil {
    log.Fatal(err)
}

totalSupply := result.(*big.Int)
fmt.Println("Total Supply:", totalSupply)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { parseAbi } from 'viem'

const totalSupply = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: parseAbi(['function totalSupply() view returns (uint256)']),
  functionName: 'totalSupply',
})

console.log('Total Supply:', totalSupply)`
    }
  ]}
/>

### Passing Arguments

Pass function arguments using the `Args` slice:

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address: common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
    ABI: \`[{
        "name": "balanceOf",
        "type": "function",
        "inputs": [{"name": "owner", "type": "address"}],
        "outputs": [{"type": "uint256"}]
    }]\`,
    FunctionName: "balanceOf",
    Args: []any{
        common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
    },
})

balance := result.(*big.Int)`
    },
    {
      title: "viem",
      language: "ts",
      code: `const balance = await publicClient.readContract({
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: parseAbi(['function balanceOf(address owner) view returns (uint256)']),
  functionName: 'balanceOf',
  args: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
})`
    }
  ]}
/>

### Parameters

The Public Client’s **ReadContract** uses **ReadContractOptions**. The **contract** package’s **ReadContract[T]** uses **ReadContractParams**. Both support the same concepts (address, ABI, function name, args, block).

### Address (required)

- **Type:** `common.Address`
- The contract address to call.

### ABI (required)

- **Type:** `any` — `string`, `[]byte`, or `*abi.ABI`
- The contract ABI as JSON bytes, a JSON string, or a pre-parsed **\*abi.ABI** from [abi.Parse](/docs/abi/parse/).

### FunctionName (required)

- **Type:** `string`
- The name of the view/pure function to call (e.g. `"balanceOf"`, `"totalSupply"`).

### Args (optional)

- **Type:** `[]any`
- **Default:** `nil`
- Function arguments in order. Omit for functions with no parameters.

### From (optional)

- **Type:** `*common.Address`
- **Default:** `nil`
- Caller address used for the call. Some contracts use this for access control or modifiers.

### Block / BlockTag (optional)

- **Type:** `client.BlockTag` (e.g. `client.BlockTagLatest`, `"safe"`, `"0x1234"`) or **BlockTag** in **ReadContractParams**
- **Default:** latest
- Block at which to execute the read (e.g. `client.BlockTagSafe`, hex block number).

### Return type

- **PublicClient.ReadContract(ctx, opts)** returns `(any, error)`. The decoded value is the first return value (e.g. `*big.Int`, `string`, `common.Address`). For multiple return values, use **contract.ReadContract** with a struct type or **SimulateContract** which returns `[]any`.
- **contract.ReadContract[T](client, params)** returns `(T, error)` with type-safe result (e.g. `ReadContract[*big.Int]`, `ReadContract[string]`). Use **contract.ReadContractWithContext** when you need to pass a context.

### SimulateContract

Use **SimulateContract** to run a contract call (including state-changing functions) without sending a transaction. Useful to check revert reasons or return values before writing. See [Simulate Contract](/docs/contract/simulate-contract/).

```go
result, err := publicClient.SimulateContract(ctx, client.SimulateContractOptions{
    ReadContractOptions: client.ReadContractOptions{
        Address:      contractAddress,
        ABI:          abi,
        FunctionName: "transfer",
        Args:         []any{recipient, amount},
        From:         &sender,
    },
    Value: big.NewInt(0),
})
```

### Using Typed Contract Bindings

For frequently used contracts, viem-go provides pre-built typed bindings:

<CodeGroup 

  tabs={[
    {
      title: "Typed Binding",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/contracts/erc20"

// Create typed ERC20 instance
usdc := common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
token, err := erc20.New(usdc, publicClient)
if err != nil {
    log.Fatal(err)
}

// Call typed methods - no ABI needed
balance, err := token.BalanceOf(ctx, ownerAddress)
name, err := token.Name(ctx)
symbol, err := token.Symbol(ctx)
decimals, err := token.Decimals(ctx)
totalSupply, err := token.TotalSupply(ctx)
allowance, err := token.Allowance(ctx, owner, spender)`
    },
    {
      title: "Raw ReadContract",
      language: "go",
      code: `// Same operation without typed binding
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
    ABI:          erc20ABI,
    FunctionName: "balanceOf",
    Args:         []any{ownerAddress},
})
balance := result.(*big.Int)`
    }
  ]}
/>

### Available Bindings

| Contract | Import | Methods |
|----------|--------|---------|
| ERC20 | `contracts/erc20` | `BalanceOf`, `Name`, `Symbol`, `Decimals`, `TotalSupply`, `Allowance` |
| ERC721 | `contracts/erc721` | `BalanceOf`, `OwnerOf`, `Name`, `Symbol`, `TokenURI`, `GetApproved` |
| ERC1155 | `contracts/erc1155` | `BalanceOf`, `BalanceOfBatch`, `URI`, `IsApprovedForAll` |

### Reading at Specific Blocks

Query contract state at a specific block:

```go
// Read at block number
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "totalSupply",
    Block:        "0xE8D4A0", // Block number as hex
})

// Read at block tag
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "totalSupply",
    Block:        client.BlockTagSafe,
})
```

### Error Handling

Contract calls can fail for various reasons:

```go
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "balanceOf",
    Args:         []any{owner},
})

if err != nil {
    // Check for revert
    if strings.Contains(err.Error(), "execution reverted") {
        log.Println("Contract reverted")
    }
    // Check for invalid function
    if strings.Contains(err.Error(), "method not found") {
        log.Println("Function doesn't exist on contract")
    }
    return err
}
```

### See also

- [Writing Contracts](/docs/contract/write-contract/) — PrepareContractWrite, WriteContract
- [Simulate Contract](/docs/contract/simulate-contract/) — SimulateContract
- [Get Code](/docs/contract/get-code/) — GetCode
- [Multicall](/docs/contract/multicall/) — batch readContract calls
- [ABI Decoding](/docs/contract/abi-decoding/) — DecodeFunctionResult

### Type Conversions

The result type depends on the Solidity return type:

| Solidity Type | Go Type |
|---------------|---------|
| `uint256`, `int256` | `*big.Int` |
| `uint8` - `uint128` | `*big.Int` |
| `address` | `common.Address` |
| `bool` | `bool` |
| `string` | `string` |
| `bytes` | `[]byte` |
| `bytes32` | `[32]byte` |
| `tuple` | `struct` or `map[string]any` |
| `array` | slice |

```go
// Casting results
balance := result.(*big.Int)
owner := result.(common.Address)
approved := result.(bool)
name := result.(string)
data := result.([]byte)
```
