---
title: Writing Contracts
description: Send transactions to modify smart contract state
---


Send transactions to modify smart contract state. Unlike read operations, writes require gas and must be signed.

### Preparing a Contract Write

Use `PrepareContractWrite` to build a transaction for a contract call:

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import (
    "github.com/ethereum/go-ethereum/common"
    "github.com/ChefBingbong/viem-go/client"
    "math/big"
)

// Prepare the transaction
tx, err := publicClient.PrepareContractWrite(ctx, client.PrepareContractWriteOptions{
    Address: common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
    ABI: \`[{
        "name": "transfer",
        "type": "function",
        "inputs": [
            {"name": "to", "type": "address"},
            {"name": "amount", "type": "uint256"}
        ],
        "outputs": [{"type": "bool"}]
    }]\`,
    FunctionName: "transfer",
    Args: []any{
        common.HexToAddress("0xRecipient..."),
        big.NewInt(1000000), // 1 USDC (6 decimals)
    },
    From: senderAddress,
})
if err != nil {
    log.Fatal(err)
}

fmt.Printf("To: %s\\n", tx.To.Hex())
fmt.Printf("Data: 0x%x\\n", tx.Data)
fmt.Printf("Gas: %d\\n", tx.Gas)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { parseAbi } from 'viem'

// Simulate first to check if it will succeed
const { request } = await publicClient.simulateContract({
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: parseAbi(['function transfer(address to, uint256 amount) returns (bool)']),
  functionName: 'transfer',
  args: ['0xRecipient...', 1000000n],
  account: senderAddress,
})

// Then write
const hash = await walletClient.writeContract(request)`
    }
  ]}
/>

### Parameters

**PrepareContractWrite** uses **PrepareContractWriteOptions**. **wallet.WriteContract** uses **WriteContractParameters**; **WriteContractSync** uses **WriteContractSyncParameters** (embeds **WriteContractParameters** plus polling/timeout). **wallet.DeployContract** uses **DeployContractParameters**.

### Address (required for write)

- **Type:** `common.Address` (PrepareContractWrite) or `string` (WriteContractParameters)
- The contract address to call.

### ABI (required)

- **Type:** `any` — `string`, `[]byte`, or `*abi.ABI`
- Contract ABI for encoding the function call.

### FunctionName (required for write)

- **Type:** `string`
- The name of the function to call (e.g. `"transfer"`, `"approve"`).

### Args (optional)

- **Type:** `[]any`
- **Default:** `nil`
- Function arguments in order.

### From / Account (required for write)

- **Type:** `common.Address` (PrepareContractWrite) or **Account** (WriteContractParameters: optional if client has default account)
- Sender address. For **WriteContract** / **WriteContractSync**, omit if the Wallet Client has a default account.

### Value (optional)

- **Type:** `*big.Int`
- **Default:** `nil`
- ETH to send with the transaction (for payable functions).

### Gas, GasPrice, MaxFeePerGas, MaxPriorityFeePerGas (optional)

- **Type:** `uint64` (Gas for PrepareContractWrite), `*big.Int` (Gas in wallet params), `*big.Int` (GasPrice, MaxFeePerGas, MaxPriorityFeePerGas)
- **Default:** Gas is estimated if not set; fees from chain or client defaults.
- Override gas limit or fee parameters.

### Nonce (optional)

- **Type:** `*uint64` (PrepareContractWrite) or `*int` (wallet params)
- **Default:** Fetched from chain (pending nonce) if not provided.

### WriteContractSync-only: PollingInterval, ThrowOnReceiptRevert, Timeout (optional)

- **PollingInterval:** `time.Duration` — interval to poll for receipt. Default: client’s polling interval.
- **ThrowOnReceiptRevert:** `*bool` — if true, return error when receipt status is reverted. Default: true.
- **Timeout:** `*time.Duration` — max wait for receipt. Default: derived from chain block time.

### Signing and Sending

After preparing, sign and send the transaction:

<CodeGroup 

  tabs={[
    {
      title: "Local Account",
      language: "go",
      code: `import (
    "github.com/ChefBingbong/viem-go/accounts"
    "github.com/ChefBingbong/viem-go/utils/transaction"
)

// 1. Create account from private key
account, _ := accounts.PrivateKeyToAccount("0x...")

// 2. Prepare the transaction
tx, _ := publicClient.PrepareContractWrite(ctx, client.PrepareContractWriteOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "transfer",
    Args:         []any{recipient, amount},
    From:         common.HexToAddress(account.Address),
})

// 3. Convert to transaction for signing
signableTx := &transaction.Transaction{
    To:       tx.To,
    Data:     tx.Data,
    Value:    tx.Value,
    Gas:      tx.Gas,
    GasPrice: tx.GasPrice,
    Nonce:    *tx.Nonce,
    ChainID:  tx.ChainID,
}

// 4. Sign the transaction
signedTx, err := account.SignTransaction(signableTx)
if err != nil {
    log.Fatal(err)
}

// 5. Send the signed transaction
txHash, err := walletClient.SendRawTransaction(ctx, []byte(signedTx))
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Transaction sent: %s\\n", txHash.Hex())

// 6. Wait for receipt
receipt, err := publicClient.WaitForTransactionReceipt(ctx, txHash)
fmt.Printf("Status: %d\\n", receipt.Status)`
    },
    {
      title: "JSON-RPC Wallet",
      language: "go",
      code: `// If your RPC endpoint manages the account (less common)
txHash, err := walletClient.SendTransaction(ctx, types.Transaction{
    From:  senderAddress,
    To:    tx.To,
    Data:  tx.Data,
    Value: tx.Value,
    Gas:   tx.Gas,
})`
    }
  ]}
/>

### Using Typed Contract Bindings

The ERC20 binding includes write methods:

```go
import "github.com/ChefBingbong/viem-go/contracts/erc20"

token, _ := erc20.New(usdcAddress, publicClient)

// Prepare a transfer
tx, err := token.PrepareTransfer(ctx, recipient, amount, senderAddress)
if err != nil {
    log.Fatal(err)
}

// Sign and send...
```

### Payable Functions

For functions that accept ETH, use the `Value` parameter:

```go
tx, err := publicClient.PrepareContractWrite(ctx, client.PrepareContractWriteOptions{
    Address:      wethAddress,
    ABI:          `[{"name":"deposit","type":"function","inputs":[],"stateMutability":"payable"}]`,
    FunctionName: "deposit",
    From:         senderAddress,
    Value:        big.NewInt(1e18), // 1 ETH
})
```

### Encoding Function Data

If you need just the calldata without a full transaction:

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/client"

data, err := client.EncodeFunctionData(client.EncodeFunctionDataOptions{
    ABI: \`[{
        "name": "transfer",
        "type": "function",
        "inputs": [
            {"name": "to", "type": "address"},
            {"name": "amount", "type": "uint256"}
        ]
    }]\`,
    FunctionName: "transfer",
    Args: []any{recipient, amount},
})

fmt.Printf("Calldata: 0x%x\\n", data)
// Output: 0xa9059cbb000000000000000000000000...`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { encodeFunctionData, parseAbi } from 'viem'

const data = encodeFunctionData({
  abi: parseAbi(['function transfer(address to, uint256 amount)']),
  functionName: 'transfer',
  args: [recipient, amount],
})

console.log('Calldata:', data)`
    }
  ]}
/>

### Gas Estimation

Gas is automatically estimated, but you can override:

```go
// Let it estimate (adds 20% buffer)
tx, _ := publicClient.PrepareContractWrite(ctx, client.PrepareContractWriteOptions{
    // ...
})
fmt.Printf("Estimated gas: %d\n", tx.Gas)

// Or specify manually
tx, _ := publicClient.PrepareContractWrite(ctx, client.PrepareContractWriteOptions{
    // ...
    Gas: 100000,
})
```

### DeployContract

To deploy a new contract, use **wallet.DeployContract** with bytecode and optional constructor args. See [Deploy Contract](/docs/contract/deploy-contract/).

### EstimateContractGas

Estimate gas for a write without sending: use **public.EstimateContractGas**. See [Estimate Contract Gas](/docs/contract/estimate-contract-gas/).

### EncodeFunctionData

**client.EncodeFunctionData(opts)** returns only the calldata (selector + encoded args) without building a full transaction. Useful for multicall or custom tx building. See [ABI Encoding](/docs/contract/abi-encoding/) for encoding with a parsed ABI.

### Error handling

```go
tx, err := publicClient.PrepareContractWrite(ctx, opts)
if err != nil {
    if strings.Contains(err.Error(), "execution reverted") {
        log.Println("Transaction would revert")
    }
    return err
}
```

### See also

- [Reading Contracts](/docs/contract/read-contract/) — ReadContract, SimulateContract
- [Deploy Contract](/docs/contract/deploy-contract/) — DeployContract
- [Estimate Contract Gas](/docs/contract/estimate-contract-gas/) — EstimateContractGas
- [Simulate Contract](/docs/contract/simulate-contract/) — test writes without sending
- [ABI Encoding](/docs/contract/abi-encoding/) — EncodeFunctionData on *ABI
