---
title: Why viem-go
description: Learn why viem-go provides a better developer experience for Ethereum in Go
---


<div data-pagefind-weight="10">

viem-go brings a modern, high-level Ethereum developer experience to the Go ecosystem — inspired by the architecture and abstractions pioneered by TypeScript [viem](https://viem.sh).

If you want the deeper "how it works" view (call flows, package responsibilities, and where the benchmark wins come from), see **[Architecture](/docs/architecture/)**.

### Why viem-go?

- **Go lacks high-level Ethereum abstractions**: There isn't a widely adopted, high-level Ethereum API abstraction in the Go ecosystem that makes common tasks feel straightforward.
- **go-ethereum is low-level by design**: go-ethereum is excellent, but working directly with its lower-level APIs can be tedious and creates a higher barrier to entry for day-to-day EVM development in Go.
- **viem is a familiar mental model**: Many web3 developers already know viem's Client/Transport/Action patterns and are comfortable reading and writing that style of code.
- **Bring viem's patterns to Go**: viem-go takes the same composable abstractions (clients, transports, typed parameter structs) and adapts them into idiomatic Go to make EVM development more enjoyable.
- **Unlock Go performance advantages**: Go can address performance bottlenecks common in TypeScript workloads using concurrency and goroutines.
- **High-level without sacrificing performance**: viem-go aims to provide a high-level API without giving up performance relative to go-ethereum, and to build on efficiency advantages over TypeScript viem where possible.

<Aside type="tip">
<span>viem-go uses go-ethereum under the hood for cryptographic primitives like Keccak256, ECDSA, and ABI encoding. If you already have go-ethereum experience, that knowledge transfers directly.</span>
</Aside>

### Benchmarks

Benchmarks are run against the same Anvil instance (mainnet fork) for a fair comparison.

| Metric | Go (viem-go) | TypeScript (viem) |
|--------|--------------|-------------------|
| Geometric mean speedup | 7.12x | - |
| Avg ns/op | 2,020,982 | 10,567,395 |
| Avg ops/s | 495 | 95 |
| Wins | 59/59 | 0/59 |

See the **[Performance](/docs/performance/)** page for interactive charts, per-test analysis, and full results across all 9 suites.

</div>

### Why Not Just Use go-ethereum?

go-ethereum is excellent for low-level operations, but it can be verbose for common tasks. viem-go provides higher-level abstractions while still using go-ethereum under the hood for cryptographic primitives.

<CodeGroup 

  tabs={[
    {
      title: "viem-go",
      language: "go",
      code: `// Reading an ERC20 balance
result, _ := client.ReadContract(ctx, client.ReadContractOptions{
    Address:      common.HexToAddress("0xA0b86991c..."),
    ABI:          \`[{"name":"balanceOf","type":"function",...}]\`,
    FunctionName: "balanceOf",
    Args:         []any{ownerAddress},
})
balance := result.(*big.Int)`
    },
    {
      title: "go-ethereum",
      language: "go",
      code: `// The same operation with raw go-ethereum
contractABI, _ := abi.JSON(strings.NewReader(abiJSON))
data, _ := contractABI.Pack("balanceOf", ownerAddress)
msg := ethereum.CallMsg{To: &contractAddr, Data: data}
result, _ := client.CallContract(ctx, msg, nil)
var balance *big.Int
contractABI.UnpackIntoInterface(&balance, "balanceOf", result)`
    }
  ]}
/>

<Aside type="caution">
<span>viem-go is under active development. While the core API is stable, some interfaces may change between minor releases. Pin your dependency version in production and check the changelog before upgrading.</span>
</Aside>

### Design Principles

### 1. Mirror viem's API

When possible, viem-go uses the same function names, option structs, and patterns as viem. This makes it easy to translate examples and share knowledge between TypeScript and Go codebases.

### 2. Idiomatic Go

While mirroring viem, we embrace Go conventions:
- Explicit error handling (no panic)
- Context for cancellation
- Interfaces for flexibility
- Struct options instead of variadic params

<Aside type="tip">
<span>Every viem-go method that hits the network accepts a <code>context.Context</code> as its first argument. Use <code>context.WithTimeout</code> or <code>context.WithCancel</code> to control request lifetimes and avoid hanging calls.</span>
</Aside>

### 3. Built on go-ethereum

viem-go doesn't reinvent cryptographic wheels. It uses go-ethereum for:
- Keccak256 hashing
- ECDSA signing
- ABI encoding/decoding
- RLP serialization

### 4. Comprehensive Testing

The test suite runs against actual Ethereum nodes (via Anvil) to ensure real-world compatibility.

### What's Implemented

viem-go is under active development. Current features include:

<DocsTable
  headers={['Feature', 'Status']}
  rows={[
    ['Public Client', '✅ Complete'],
    ['Wallet Client', '✅ Complete'],
    ['HTTP Transport', '✅ Complete'],
    ['WebSocket Transport', '✅ Complete'],
    ['Read Contract', '✅ Complete'],
    ['Write Contract', '✅ Complete'],
    ['Account Management', '✅ Complete'],
    ['ABI Encoding/Decoding', '✅ Complete'],
    ['Unit Utilities', '✅ Complete'],
    ['Signature Utilities', '✅ Complete'],
    ['ERC20/721/1155 Bindings', '✅ Complete'],
  ]}
/>


### Getting Started

Ready to dive in? Head to the [Getting Started](/docs/getting-started/) guide to set up your first viem-go project.
