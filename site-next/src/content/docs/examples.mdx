---
title: Examples
description: Real-world examples showing viem-go in action, with TypeScript comparisons
---


### Basic Examples

### Get Transaction Receipt

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `txHash := common.HexToHash("0x...")

receipt, err := c.GetTransactionReceipt(context.Background(), txHash) // [!code focus]
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Status: %d\\n", receipt.Status)
fmt.Printf("Gas Used: %d\\n", receipt.GasUsed)
fmt.Printf("Block: %d\\n", receipt.BlockNumber)`
    },
    {
      title: "viem",
      language: "ts",
      code: `const receipt = await client.getTransactionReceipt({
  hash: '0x...',
})

console.log('Status:', receipt.status)
console.log('Gas Used:', receipt.gasUsed)
console.log('Block:', receipt.blockNumber)`
    }
  ]}
/>

### Contract Examples

#### Read ERC20 Token Info

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/contracts/erc20"

usdcAddress := common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48") // [!code focus]
token, _ := erc20.New(usdcAddress, publicClient)

name, _ := token.Name(context.Background())
symbol, _ := token.Symbol(context.Background())
decimals, _ := token.Decimals(context.Background())
totalSupply, _ := token.TotalSupply(context.Background())

fmt.Printf("Token: %s (%s)\\n", name, symbol)
fmt.Printf("Decimals: %d\\n", decimals)
fmt.Printf("Total Supply: %s\\n", totalSupply.String())`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { erc20Abi, formatUnits } from 'viem'

const usdcAddress = '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48'

const [name, symbol, decimals, totalSupply] = await Promise.all([
  client.readContract({ address: usdcAddress, abi: erc20Abi, functionName: 'name' }),
  client.readContract({ address: usdcAddress, abi: erc20Abi, functionName: 'symbol' }),
  client.readContract({ address: usdcAddress, abi: erc20Abi, functionName: 'decimals' }),
  client.readContract({ address: usdcAddress, abi: erc20Abi, functionName: 'totalSupply' }),
])

console.log(\`Token: \${name} (\${symbol})\`)
console.log(\`Decimals: \${decimals}\`)
console.log(\`Total Supply: \${formatUnits(totalSupply, decimals)}\`)`
    }
  ]}
/>

### Encode Function Data

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/abi"

parsed, _ := abi.Parse([]byte(\`[{ // [!code focus:7]
    "name": "transfer",
    "type": "function",
    "inputs": [
        {"name": "to", "type": "address"},
        {"name": "amount", "type": "uint256"}
    ]
}]\`))

data, _ := parsed.EncodeFunctionData("transfer", // [!code focus:3]
    common.HexToAddress("0x..."),
    big.NewInt(1000000),
)

fmt.Printf("Encoded: 0x%x\\n", data)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { encodeFunctionData, parseAbi } from 'viem'

const data = encodeFunctionData({
  abi: parseAbi(['function transfer(address to, uint256 amount)']),
  functionName: 'transfer',
  args: ['0x...', 1000000n],
})

console.log('Encoded:', data)`
    }
  ]}
/>

### Account Examples

### Create Account from Private Key

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/accounts"

account, _ := accounts.PrivateKeyToAccount("0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80") // [!code focus]

fmt.Printf("Address: %s\\n", account.Address)
fmt.Printf("Public Key: %s\\n", account.PublicKey)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount('0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80')

console.log('Address:', account.address)
console.log('Public Key:', account.publicKey)`
    }
  ]}
/>

### Create Account from Mnemonic

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/accounts"

mnemonic := "test test test test test test test test test test test junk" // [!code focus:3]

account, _ := accounts.MnemonicToAccount(mnemonic, nil)

fmt.Printf("Address: %s\\n", account.Address)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { mnemonicToAccount } from 'viem/accounts'

const account = mnemonicToAccount(
  'test test test test test test test test test test test junk'
)

console.log('Address:', account.address)`
    }
  ]}
/>

### Utility Examples

### Parse and Format Units

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import "github.com/ChefBingbong/viem-go/utils/unit"

// Parse ETH to wei
wei, _ := unit.ParseEther("1.5") // [!code focus]
fmt.Println("Wei:", wei) // 1500000000000000000

// Parse USDC (6 decimals)
usdcAmount, _ := unit.ParseUnits("100", 6) // [!code focus]
fmt.Println("USDC:", usdcAmount) // 100000000

// Format back
ethString := unit.FormatEther(wei) // [!code focus]
fmt.Println("ETH:", ethString) // 1.5`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { parseEther, parseUnits, formatEther } from 'viem'

// Parse ETH to wei
const wei = parseEther('1.5')
console.log('Wei:', wei) // 1500000000000000000n

// Parse USDC (6 decimals)
const usdcAmount = parseUnits('100', 6)
console.log('USDC:', usdcAmount) // 100000000n

// Format back
const ethString = formatEther(wei)
console.log('ETH:', ethString) // "1.5"`
    }
  ]}
/>

### Hash and Signature Utilities

<CodeGroup 

  tabs={[
    {
      title: "Go",
      language: "go",
      code: `import (
    "github.com/ChefBingbong/viem-go/utils/hash"
    "github.com/ChefBingbong/viem-go/utils/signature"
)

// Keccak256 hash
h := hash.Keccak256([]byte("hello")) // [!code focus]
fmt.Printf("Hash: 0x%x\\n", h)

// Hash a message for signing (EIP-191)
messageHash := signature.HashMessage("hello world") // [!code focus]
fmt.Printf("Message Hash: 0x%x\\n", messageHash)

// Recover address from signature
address, _ := signature.RecoverMessageAddress("hello world", sig) // [!code focus]
fmt.Printf("Recovered: %s\\n", address)`
    },
    {
      title: "viem",
      language: "ts",
      code: `import { keccak256, hashMessage, recoverMessageAddress } from 'viem'

// Keccak256 hash
const hash = keccak256(toBytes('hello'))
console.log('Hash:', hash)

// Hash a message for signing (EIP-191)
const messageHash = hashMessage('hello world')
console.log('Message Hash:', messageHash)

// Recover address from signature
const address = await recoverMessageAddress({
  message: 'hello world',
  signature: sig,
})
console.log('Recovered:', address)`
    }
  ]}
/>

### Real-world (Advanced): UniswapV2 extractor in Go

These snippets are cherry-picked from the Go implementation in [`viem-go-extractor-demo`](https://github.com/ChefBingbong/viem-go-extractor-demo/tree/main) — a real UniswapV2 pool extractor that heavily exercises **multicall batching**, **concurrent fan-out**, **reorg-aware log watching**, and **on-disk caching**.

<CodeGroup
  tabs={[
    {
      title: "Batched multicall",
      language: "go",
      code: `// mini-extractor-go/extractor/univ2_extractor.go
// Batch thousands of getReserves calls via Multicall3.
func (ext *UniV2Extractor) batchGetReserves(ctx context.Context, addresses []common.Address) map[string][2]*big.Int {
	pairABI := univ2pair.MustParsedABI()
	results := make(map[string][2]*big.Int)

	for i := 0; i < len(addresses); i += multicallBatchSize {
		end := i + multicallBatchSize
		if end > len(addresses) {
			end = len(addresses)
		}
		chunk := addresses[i:end]

		contracts := make([]public.MulticallContract, len(chunk))
		for j, addr := range chunk {
			contracts[j] = public.MulticallContract{
				Address:      addr,
				ABI:          pairABI,
				FunctionName: "getReserves",
			}
		}

		mcResults, err := public.Multicall(ctx, ext.client, public.MulticallParameters{
			Contracts:    contracts,
			AllowFailure: boolPtr(true),
		})
		if err != nil {
			lib.ExtractorError("batchGetReserves multicall error", "error", err)
			continue
		}

		for j, r := range mcResults {
			addrL := strings.ToLower(chunk[j].Hex())
			if r.Status == "success" {
				if vals, ok := r.Result.([]any); ok && len(vals) >= 2 {
					r0, _ := vals[0].(*big.Int)
					r1, _ := vals[1].(*big.Int)
					if r0 != nil && r1 != nil {
						results[addrL] = [2]*big.Int{r0, r1}
					}
				}
			}
		}
	}
	return results
}`,
    },
    {
      title: "Log indexer",
      language: "go",
      code: `// mini-extractor-go/extractor/log_filter.go
// Watch block numbers, fetch blocks, then schedule log fetching/processing.
func (lf *LogFilter2) AddFilter(topics []string, onNewLogs FilterCallback) {
	lf.topicsAll = append(lf.topicsAll, topics...)
	lf.filters = append(lf.filters, FilterMy{Topics: topics, OnNewLogs: onNewLogs})
}

func (lf *LogFilter2) Start() {
	if lf.cancelWatch != nil {
		return
	}

	ctx, cancel := context.WithCancel(context.Background())
	lf.cancelWatch = cancel

	if lf.logType == LogFilterNative {
		// Not widely supported — use OneCall as fallback
		lf.logType = LogFilterOneCall
	}

	events := lf.client.WatchBlockNumber(ctx, public.WatchBlockNumberParameters{})

	go func() {
		for event := range events {
			if event.Error != nil {
				lib.ExtractorError("watchBlockNumber error", "error", event.Error)
				lf.Restart()
				return
			}

			blockNum := event.BlockNumber
			block, err := lf.client.GetBlockByNumber(ctx, blockNum, false)
			if err != nil || block == nil {
				continue
			}

			bp := &BlockParams{
				Hash:       block.Hash,
				Number:     &block.Number,
				ParentHash: block.ParentHash,
				Timestamp:  block.Timestamp,
			}

			lf.addBlock(ctx, bp, block, true)

			// Notify subscribers
			select {
			case lf.blockCh <- block.Number:
			default:
			}
		}
	}()
}

// ... later: depth frames + per-block log fetching + sorting + callbacks ...`,
    },
    {
      title: "Concurrent Multicall",
      language: "go",
      code: `// mini-extractor-go/extractor/token_manager.go
// Resolve token metadata via multicall, dedupe concurrent lookups, and fall back
// to bytes32 for tokens that don't return string().
func (tm *TokenManager) FindToken(ctx context.Context, address common.Address) (*lib.Token, error) {
	addr := strings.ToLower(address.Hex())

	// Check cache first
	if t := tm.GetKnownToken(address); t != nil {
		return t, nil
	}

	// Singleflight: deduplicate concurrent requests for the same token
	tm.inflightMu.Lock()
	if flight, ok := tm.inflight[addr]; ok {
		tm.inflightMu.Unlock()
		<-flight.done
		return flight.token, flight.err
	}
	flight := &tokenFlight{done: make(chan struct{})}
	tm.inflight[addr] = flight
	tm.inflightMu.Unlock()

	token, err := tm.fetchToken(ctx, address)

	flight.token = token
	flight.err = err
	close(flight.done)

	tm.inflightMu.Lock()
	delete(tm.inflight, addr)
	tm.inflightMu.Unlock()

	return token, err
}

func (tm *TokenManager) fetchToken(ctx context.Context, address common.Address) (*lib.Token, error) {
	erc20ABI, err := getERC20ABI()
	if err != nil {
		return nil, err
	}

	// Called from fan-out goroutines → lets the batcher merge concurrent calls.
	results, err := public.MulticallConcurrent(ctx, tm.client, public.MulticallParameters{
		Contracts: []public.MulticallContract{
			{Address: address, ABI: erc20ABI, FunctionName: "decimals"},
			{Address: address, ABI: erc20ABI, FunctionName: "symbol"},
			{Address: address, ABI: erc20ABI, FunctionName: "name"},
		},
		AllowFailure: boolPtr(true),
	})
	if err != nil {
		return nil, err
	}

	decimalsR, symbolR, nameR := results[0], results[1], results[2]
	if decimalsR.Status == "failure" {
		return nil, nil
	}
	if symbolR.Status == "failure" || nameR.Status == "failure" {
		return tm.fetchTokenBytes32(ctx, address)
	}

	token := &lib.Token{
		ChainID:  tm.chainID,
		Address:  address,
		Decimals: toInt(decimalsR.Result),
		Symbol:   toString(symbolR.Result),
		Name:     toString(nameR.Result),
	}
	tm.addToken(token, true)
	return token, nil
}`,
    },
    {
      title: "Permanent cache",
      language: "go",
      code: `// mini-extractor-go/extractor/permanent_cache.go
// JSONL-based append-only cache + in-memory dedup.
type PermanentCache[T any] struct {
	filePath     string
	mu           sync.Mutex
	knownEntries map[string]struct{}
}

func NewPermanentCache[T any](paths ...string) *PermanentCache[T] {
	fp := ""
	if len(paths) > 0 && paths[0] != "" {
		fp = filepath.Join(paths...)
	}
	return &PermanentCache[T]{filePath: fp, knownEntries: make(map[string]struct{})}
}

func (c *PermanentCache[T]) GetAllRecords() ([]T, error) {
	c.mu.Lock()
	defer c.mu.Unlock()
	// ... read JSONL, populate knownEntries ...
	return records, nil
}

func (c *PermanentCache[T]) Add(record T) {
	c.mu.Lock()
	defer c.mu.Unlock()
	// ... marshal → dedupe → mkdir → append line ...
}`,
    },
  ]}
/>

