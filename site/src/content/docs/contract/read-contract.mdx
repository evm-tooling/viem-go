---
title: Reading Contracts
description: Read data from smart contracts using view and pure functions
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Read data from smart contracts using view and pure functions. These calls don't require gas since they don't modify state.

## Basic Usage

<Tabs>
  <TabItem label="Go">
```go
import (
    "github.com/ethereum/go-ethereum/common"
    "github.com/ChefBingbong/viem-go/client"
)

result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      common.HexToAddress("0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2"),
    ABI:          `[{"name":"totalSupply","type":"function","inputs":[],"outputs":[{"type":"uint256"}]}]`,
    FunctionName: "totalSupply",
})
if err != nil {
    log.Fatal(err)
}

totalSupply := result.(*big.Int)
fmt.Println("Total Supply:", totalSupply)
```
  </TabItem>
  <TabItem label="TypeScript (viem)">
```typescript
import { parseAbi } from 'viem'

const totalSupply = await publicClient.readContract({
  address: '0xFBA3912Ca04dd458c843e2EE08967fC04f3579c2',
  abi: parseAbi(['function totalSupply() view returns (uint256)']),
  functionName: 'totalSupply',
})

console.log('Total Supply:', totalSupply)
```
  </TabItem>
</Tabs>

## Passing Arguments

Pass function arguments using the `Args` slice:

<Tabs>
  <TabItem label="Go">
```go
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address: common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
    ABI: `[{
        "name": "balanceOf",
        "type": "function",
        "inputs": [{"name": "owner", "type": "address"}],
        "outputs": [{"type": "uint256"}]
    }]`,
    FunctionName: "balanceOf",
    Args: []any{
        common.HexToAddress("0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"),
    },
})

balance := result.(*big.Int)
```
  </TabItem>
  <TabItem label="TypeScript (viem)">
```typescript
const balance = await publicClient.readContract({
  address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
  abi: parseAbi(['function balanceOf(address owner) view returns (uint256)']),
  functionName: 'balanceOf',
  args: ['0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045'],
})
```
  </TabItem>
</Tabs>

## ReadContractOptions

| Parameter | Type | Required | Description |
|-----------|------|----------|-------------|
| `Address` | `common.Address` | Yes | Contract address |
| `ABI` | `string` or `[]byte` or `*abi.ABI` | Yes | Contract ABI |
| `FunctionName` | `string` | Yes | Function to call |
| `Args` | `[]any` | No | Function arguments |
| `From` | `*common.Address` | No | Caller address (for access control) |
| `Block` | `BlockTag` | No | Block to read from (default: latest) |

## Using Typed Contract Bindings

For frequently used contracts, viem-go provides pre-built typed bindings:

<Tabs>
  <TabItem label="Go - Typed Binding">
```go
import "github.com/ChefBingbong/viem-go/contracts/erc20"

// Create typed ERC20 instance
usdc := common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48")
token, err := erc20.New(usdc, publicClient)
if err != nil {
    log.Fatal(err)
}

// Call typed methods - no ABI needed
balance, err := token.BalanceOf(ctx, ownerAddress)
name, err := token.Name(ctx)
symbol, err := token.Symbol(ctx)
decimals, err := token.Decimals(ctx)
totalSupply, err := token.TotalSupply(ctx)
allowance, err := token.Allowance(ctx, owner, spender)
```
  </TabItem>
  <TabItem label="Go - Raw ReadContract">
```go
// Same operation without typed binding
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      common.HexToAddress("0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48"),
    ABI:          erc20ABI,
    FunctionName: "balanceOf",
    Args:         []any{ownerAddress},
})
balance := result.(*big.Int)
```
  </TabItem>
</Tabs>

### Available Bindings

| Contract | Import | Methods |
|----------|--------|---------|
| ERC20 | `contracts/erc20` | `BalanceOf`, `Name`, `Symbol`, `Decimals`, `TotalSupply`, `Allowance` |
| ERC721 | `contracts/erc721` | `BalanceOf`, `OwnerOf`, `Name`, `Symbol`, `TokenURI`, `GetApproved` |
| ERC1155 | `contracts/erc1155` | `BalanceOf`, `BalanceOfBatch`, `URI`, `IsApprovedForAll` |

## Reading at Specific Blocks

Query contract state at a specific block:

```go
// Read at block number
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "totalSupply",
    Block:        "0xE8D4A0", // Block number as hex
})

// Read at block tag
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "totalSupply",
    Block:        client.BlockTagSafe,
})
```

## Simulating Calls

Use `SimulateContract` to test calls that would normally require a transaction:

```go
result, err := publicClient.SimulateContract(ctx, client.SimulateContractOptions{
    ReadContractOptions: client.ReadContractOptions{
        Address:      contractAddress,
        ABI:          abi,
        FunctionName: "transfer",
        Args:         []any{recipient, amount},
        From:         &sender,
    },
    Value: big.NewInt(0),
})
```

## Error Handling

Contract calls can fail for various reasons:

```go
result, err := publicClient.ReadContract(ctx, client.ReadContractOptions{
    Address:      contractAddress,
    ABI:          abi,
    FunctionName: "balanceOf",
    Args:         []any{owner},
})

if err != nil {
    // Check for revert
    if strings.Contains(err.Error(), "execution reverted") {
        log.Println("Contract reverted")
    }
    // Check for invalid function
    if strings.Contains(err.Error(), "method not found") {
        log.Println("Function doesn't exist on contract")
    }
    return err
}
```

## Type Conversions

The result type depends on the Solidity return type:

| Solidity Type | Go Type |
|---------------|---------|
| `uint256`, `int256` | `*big.Int` |
| `uint8` - `uint128` | `*big.Int` |
| `address` | `common.Address` |
| `bool` | `bool` |
| `string` | `string` |
| `bytes` | `[]byte` |
| `bytes32` | `[32]byte` |
| `tuple` | `struct` or `map[string]any` |
| `array` | slice |

```go
// Casting results
balance := result.(*big.Int)
owner := result.(common.Address)
approved := result.(bool)
name := result.(string)
data := result.([]byte)
```
