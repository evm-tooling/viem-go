---
title: Mnemonic Account
description: Create an account from a BIP-39 mnemonic phrase (seed phrase)
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Create an account from a BIP-39 mnemonic phrase (seed phrase).

## Usage

<Tabs>
  <TabItem label="Go">
```go
import "github.com/ChefBingbong/viem-go/accounts"

account, err := accounts.MnemonicToAccount(
    "test test test test test test test test test test test junk",
    nil, // Use default HD path: m/44'/60'/0'/0/0
)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Address: %s\n", account.Address)
// Address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```
  </TabItem>
  <TabItem label="TypeScript (viem)">
```typescript
import { mnemonicToAccount } from 'viem/accounts'

const account = mnemonicToAccount(
  'test test test test test test test test test test test junk'
)

console.log('Address:', account.address)
// Address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```
  </TabItem>
</Tabs>

## Custom Derivation Path

Derive different accounts by specifying the HD path:

<Tabs>
  <TabItem label="Go">
```go
// Default path (first account): m/44'/60'/0'/0/0
account0, _ := accounts.MnemonicToAccount(mnemonic, nil)

// Second account: m/44'/60'/0'/0/1
account1, _ := accounts.MnemonicToAccount(mnemonic, &accounts.HDOptions{
    Path: "m/44'/60'/0'/0/1",
})

// Third account: m/44'/60'/0'/0/2
account2, _ := accounts.MnemonicToAccount(mnemonic, &accounts.HDOptions{
    Path: "m/44'/60'/0'/0/2",
})

fmt.Printf("Account 0: %s\n", account0.Address)
fmt.Printf("Account 1: %s\n", account1.Address)
fmt.Printf("Account 2: %s\n", account2.Address)
```
  </TabItem>
  <TabItem label="TypeScript (viem)">
```typescript
// Default (first account)
const account0 = mnemonicToAccount(mnemonic)

// Second account
const account1 = mnemonicToAccount(mnemonic, { addressIndex: 1 })

// Third account  
const account2 = mnemonicToAccount(mnemonic, { addressIndex: 2 })

// Or with full custom path
const customAccount = mnemonicToAccount(mnemonic, {
  path: "m/44'/60'/0'/0/5"
})
```
  </TabItem>
</Tabs>

## HD Path Explanation

The standard Ethereum HD path `m/44'/60'/0'/0/0` breaks down as:

| Component | Meaning |
|-----------|---------|
| `m` | Master node |
| `44'` | BIP-44 purpose (hardened) |
| `60'` | Ethereum coin type (hardened) |
| `0'` | Account index (hardened) |
| `0` | Change (external = 0, internal = 1) |
| `0` | Address index |

Most wallets increment the last number for multiple addresses.

## Generating a Mnemonic

Generate a new cryptographically secure mnemonic:

```go
// Generate 12-word mnemonic (128 bits entropy)
mnemonic12, err := accounts.GenerateMnemonic(12)
if err != nil {
    log.Fatal(err)
}
fmt.Println("12 words:", mnemonic12)

// Generate 24-word mnemonic (256 bits entropy)  
mnemonic24, err := accounts.GenerateMnemonic(24)
if err != nil {
    log.Fatal(err)
}
fmt.Println("24 words:", mnemonic24)
```

## Signing Operations

Mnemonic accounts have all the same signing capabilities as private key accounts:

```go
// Sign a message
sig, err := account.SignMessage(signature.SignableMessage{
    Raw: []byte("Hello!"),
})

// Sign a transaction
signedTx, err := account.SignTransaction(tx)

// Sign typed data
sig, err := account.SignTypedData(typedData)
```

See [Private Key Account](/docs/accounts/private-key/) for detailed signing examples.

## Deriving Multiple Accounts

For deriving many accounts efficiently:

```go
mnemonic := "test test test test test test test test test test test junk"

// Derive accounts 0-9
accounts := make([]*accounts.HDAccount, 10)
for i := 0; i < 10; i++ {
    path := fmt.Sprintf("m/44'/60'/0'/0/%d", i)
    accounts[i], _ = accounts.MnemonicToAccount(mnemonic, &accounts.HDOptions{
        Path: path,
    })
    fmt.Printf("Account %d: %s\n", i, accounts[i].Address)
}
```

## Wordlists

viem-go supports the standard BIP-39 English wordlist. The mnemonic must use valid words from this list.

```go
// Validate a mnemonic
isValid := accounts.ValidateMnemonic("test test test test test test test test test test test junk")
fmt.Println("Valid:", isValid) // true

isValid = accounts.ValidateMnemonic("invalid words here")
fmt.Println("Valid:", isValid) // false
```
