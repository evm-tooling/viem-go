# Private Key Account

Create an account from a private key for signing transactions and messages locally.

## Usage

:::code-group

```go [Go]
import "github.com/ChefBingbong/viem-go/accounts"

account, err := accounts.PrivateKeyToAccount(
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
)
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Address: %s\n", account.Address)
// Address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```

```typescript [TypeScript (viem)]
import { privateKeyToAccount } from 'viem/accounts'

const account = privateKeyToAccount(
  '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80'
)

console.log('Address:', account.address)
// Address: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266
```

:::

## Signing Messages

Sign an EIP-191 personal message:

:::code-group

```go [Go]
import "github.com/ChefBingbong/viem-go/utils/signature"

sig, err := account.SignMessage(signature.SignableMessage{
    Raw: []byte("Hello, Ethereum!"),
})
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Signature: %s\n", sig)
```

```typescript [TypeScript (viem)]
const signature = await account.signMessage({
  message: 'Hello, Ethereum!',
})

console.log('Signature:', signature)
```

:::

## Signing Transactions

:::code-group

```go [Go]
import (
    "github.com/ChefBingbong/viem-go/utils/transaction"
    "math/big"
)

tx := &transaction.Transaction{
    To:       &recipientAddress,
    Value:    big.NewInt(1e18), // 1 ETH
    Gas:      21000,
    GasPrice: big.NewInt(20e9), // 20 gwei
    Nonce:    0,
    ChainID:  big.NewInt(1), // Mainnet
}

signedTx, err := account.SignTransaction(tx)
if err != nil {
    log.Fatal(err)
}

// signedTx is the serialized signed transaction ready to broadcast
fmt.Printf("Signed TX: %s\n", signedTx)
```

```typescript [TypeScript (viem)]
const signature = await account.signTransaction({
  to: recipientAddress,
  value: parseEther('1'),
  gas: 21000n,
  gasPrice: parseGwei('20'),
  nonce: 0,
  chainId: 1,
})
```

:::

## Signing Typed Data (EIP-712)

:::code-group

```go [Go]
import "github.com/ChefBingbong/viem-go/utils/signature"

typedData := signature.TypedDataDefinition{
    Domain: signature.TypedDataDomain{
        Name:              "Ether Mail",
        Version:           "1",
        ChainId:           big.NewInt(1),
        VerifyingContract: common.HexToAddress("0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"),
    },
    Types: map[string][]signature.TypedDataField{
        "Person": {
            {Name: "name", Type: "string"},
            {Name: "wallet", Type: "address"},
        },
        "Mail": {
            {Name: "from", Type: "Person"},
            {Name: "to", Type: "Person"},
            {Name: "contents", Type: "string"},
        },
    },
    PrimaryType: "Mail",
    Message: map[string]any{
        "from": map[string]any{
            "name":   "Alice",
            "wallet": "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
        },
        "to": map[string]any{
            "name":   "Bob",
            "wallet": "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
        },
        "contents": "Hello, Bob!",
    },
}

sig, err := account.SignTypedData(typedData)
```

```typescript [TypeScript (viem)]
const signature = await account.signTypedData({
  domain: {
    name: 'Ether Mail',
    version: '1',
    chainId: 1,
    verifyingContract: '0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC',
  },
  types: {
    Person: [
      { name: 'name', type: 'string' },
      { name: 'wallet', type: 'address' },
    ],
    Mail: [
      { name: 'from', type: 'Person' },
      { name: 'to', type: 'Person' },
      { name: 'contents', type: 'string' },
    ],
  },
  primaryType: 'Mail',
  message: {
    from: { name: 'Alice', wallet: '0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826' },
    to: { name: 'Bob', wallet: '0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB' },
    contents: 'Hello, Bob!',
  },
})
```

:::

## Generating a Private Key

Generate a cryptographically secure random private key:

```go
privateKey, err := accounts.GeneratePrivateKey()
if err != nil {
    log.Fatal(err)
}

fmt.Printf("Generated: %s\n", privateKey)
// 0x... (64 hex characters)

account, _ := accounts.PrivateKeyToAccount(privateKey)
```

## Error Handling

```go
account, err := accounts.PrivateKeyToAccount(privateKey)
if err != nil {
    switch {
    case err == accounts.ErrInvalidPrivateKey:
        log.Println("Invalid private key format")
    case err == accounts.ErrPrivateKeyLength:
        log.Println("Private key must be 32 bytes")
    default:
        log.Printf("Unknown error: %v", err)
    }
    return
}
```
