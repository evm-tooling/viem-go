package codegen

// contractTemplate is the main template for generating contract bindings.
const contractTemplate = `// Code generated by viemgen. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"math/big"

	"github.com/ChefBingbong/viem-go/client"
	"github.com/ChefBingbong/viem-go/contract"
	"github.com/ethereum/go-ethereum/common"
)

// Suppress unused import warnings
var (
	_ = big.NewInt
	_ = common.Address{}
)

// ContractABI is the ABI of the {{.ContractName}} contract.
var ContractABI = ` + "`" + `{{.ABIJSON}}` + "`" + `

// {{.ContractName}} is a binding to the {{.ContractName}} contract.
type {{.ContractName}} struct {
	contract *contract.Contract
}

// New creates a new {{.ContractName}} contract binding.
func New(address common.Address, c *client.Client) (*{{.ContractName}}, error) {
	cont, err := contract.NewContract(address, []byte(ContractABI), c)
	if err != nil {
		return nil, err
	}
	return &{{.ContractName}}{contract: cont}, nil
}

// MustNew creates a new {{.ContractName}} contract binding, panicking on error.
func MustNew(address common.Address, c *client.Client) *{{.ContractName}} {
	cont, err := New(address, c)
	if err != nil {
		panic(err)
	}
	return cont
}

// Address returns the contract address.
func (c *{{.ContractName}}) Address() common.Address {
	return c.contract.Address()
}

// Contract returns the underlying contract instance.
func (c *{{.ContractName}}) Contract() *contract.Contract {
	return c.contract
}

{{range .Functions}}
{{if .IsReadOnly}}
// {{.GoName}} calls the {{.Name}} function.
// Solidity: {{.Signature}}
func (c *{{$.ContractName}}) {{.GoName}}(ctx context.Context{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) ({{if eq (len .Outputs) 1}}{{(index .Outputs 0).GoType}}{{else if gt (len .Outputs) 1}}({{range $i, $o := .Outputs}}{{if $i}}, {{end}}{{$o.GoType}}{{end}}){{else}}error{{end}}, error) {
	result, err := c.contract.Read(ctx, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
	if err != nil {
		return {{if eq (len .Outputs) 1}}{{zeroValue (index .Outputs 0).GoType}}{{else if gt (len .Outputs) 1}}{{range $i, $o := .Outputs}}{{if $i}}, {{end}}{{zeroValue $o.GoType}}{{end}}{{end}}, err
	}
	{{if eq (len .Outputs) 0}}
	return nil
	{{else if eq (len .Outputs) 1}}
	return result[0].({{(index .Outputs 0).GoType}}), nil
	{{else}}
	return {{range $i, $o := .Outputs}}{{if $i}}, {{end}}result[{{$i}}].({{$o.GoType}}){{end}}, nil
	{{end}}
}
{{else}}
// {{.GoName}} sends a transaction to the {{.Name}} function.
// Solidity: {{.Signature}}
func (c *{{$.ContractName}}) {{.GoName}}(ctx context.Context, opts contract.WriteOptions{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) (common.Hash, error) {
	return c.contract.Write(ctx, opts, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
}

// {{.GoName}}AndWait sends a transaction and waits for the receipt.
func (c *{{$.ContractName}}) {{.GoName}}AndWait(ctx context.Context, opts contract.WriteOptions{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) (*client.Receipt, error) {
	return c.contract.WriteAndWait(ctx, opts, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
}
{{end}}
{{end}}

{{if .HasEvents}}
// Event types
{{range .Events}}
// {{.GoName}}Event represents a {{.Name}} event.
type {{.GoName}}Event struct {
{{range .Inputs}}	{{.GoName}} {{.GoType}}
{{end}}}

{{end}}
{{end}}
`

// init adds zero value helper to template funcs.
func init() {
	templateFuncs["zeroValue"] = zeroValue
}

// zeroValue returns the zero value for a Go type.
func zeroValue(goType string) string {
	switch goType {
	case "bool":
		return "false"
	case "string":
		return `""`
	case "*big.Int":
		return "nil"
	case "common.Address":
		return "common.Address{}"
	case "common.Hash":
		return "common.Hash{}"
	case "[]byte":
		return "nil"
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		return "0"
	default:
		if goType[0] == '[' {
			// Array type
			return goType + "{}"
		}
		if goType[0] == '*' {
			return "nil"
		}
		return "nil"
	}
}

// eventTemplate is the template for event parsing helpers.
const eventTemplate = `
// Parse{{.GoName}} parses a {{.Name}} event from a log.
func (c *{{$.ContractName}}) Parse{{.GoName}}(log client.Log) (*{{.GoName}}Event, error) {
	event, err := c.contract.DecodeEvent("{{.Name}}", log.Topics, log.Data)
	if err != nil {
		return nil, err
	}
	
	ev := &{{.GoName}}Event{}
	{{range $i, $input := .Inputs}}
	if v, ok := event["{{$input.Name}}"]; ok {
		ev.{{$input.GoName}} = v.({{$input.GoType}})
	}
	{{end}}
	
	return ev, nil
}
`

// multicallTemplate generates multicall helper code.
const multicallTemplate = `
// Multicall helpers for batching multiple calls.

// {{.ContractName}}Calls holds multiple call builders for the contract.
type {{.ContractName}}Calls struct {
	contract *{{.ContractName}}
	calls    [][]byte
}

// NewCalls creates a new call builder.
func (c *{{.ContractName}}) NewCalls() *{{.ContractName}}Calls {
	return &{{.ContractName}}Calls{contract: c}
}

{{range .Functions}}
{{if .IsReadOnly}}
// Add{{.GoName}} adds a {{.Name}} call to the batch.
func (b *{{$.ContractName}}Calls) Add{{.GoName}}({{range $i, $input := .Inputs}}{{if $i}}, {{end}}{{$input.GoName}} {{$input.GoType}}{{end}}) *{{$.ContractName}}Calls {
	data, _ := b.contract.contract.EncodeCall("{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
	b.calls = append(b.calls, data)
	return b
}
{{end}}
{{end}}

// Calldata returns all encoded calldata for the batch.
func (b *{{.ContractName}}Calls) Calldata() [][]byte {
	return b.calls
}
`
