package codegen

// contractTemplate is the main template for generating contract bindings.
const contractTemplate = `// Code generated by viemgen. DO NOT EDIT.
package {{.PackageName}}

import (
	"context"
	"math/big"
	"sync"

	"github.com/ChefBingbong/viem-go/abi"
	"github.com/ChefBingbong/viem-go/client"
	"github.com/ChefBingbong/viem-go/contract"
	"github.com/ChefBingbong/viem-go/types"
	"github.com/ethereum/go-ethereum/common"
)

// Suppress unused import warnings
var (
	_ = big.NewInt
	_ = common.Address{}
	_ types.Transaction
	_ sync.Once
	_ *abi.ABI
)

// ContractABI is the raw JSON ABI of the {{.ContractName}} contract.
var ContractABI = ` + "`" + `{{.ABIJSON}}` + "`" + `

// parsedABI holds the parsed ABI (lazily initialized).
var (
	parsedABI     *abi.ABI
	parsedABIOnce sync.Once
	parsedABIErr  error
)

// ParsedABI returns the pre-parsed ABI for the {{.ContractName}} contract.
// This is useful for efficient multicall operations where you want to avoid
// re-parsing the ABI JSON on every call.
// The ABI is parsed once and cached for subsequent calls.
func ParsedABI() (*abi.ABI, error) {
	parsedABIOnce.Do(func() {
		parsedABI, parsedABIErr = abi.Parse([]byte(ContractABI))
	})
	return parsedABI, parsedABIErr
}

// MustParsedABI returns the pre-parsed ABI, panicking on error.
// Use this when you're confident the ABI is valid (e.g., in init or tests).
func MustParsedABI() *abi.ABI {
	parsed, err := ParsedABI()
	if err != nil {
		panic("failed to parse {{.ContractName}} ABI: " + err.Error())
	}
	return parsed
}

// ============================================================================
// Typed Method Descriptors
// ============================================================================

// {{.ContractName}}Methods defines typed method descriptors for the {{.ContractName}} contract.
// Use these with contract.ReadTyped() for type-safe calls.
type {{.ContractName}}Methods struct {
{{range .Functions}}	{{.GoName}} {{.TypedMethod}}
{{end}}}

// Methods is the typed method descriptors instance for {{.ContractName}}.
// Use with contract.ReadTyped(c.Contract(), ctx, Methods.MethodName, args...)
var Methods = {{.ContractName}}Methods{
{{range .Functions}}	{{.GoName}}: {{.TypedMethod}}{Name: "{{.Name}}"},
{{end}}}

// ============================================================================
// Contract Binding
// ============================================================================

// {{.ContractName}} is a binding to the {{.ContractName}} contract.
type {{.ContractName}} struct {
	contract *contract.Contract
	M        {{.ContractName}}Methods // Typed method descriptors
}

// New creates a new {{.ContractName}} contract binding.
func New(address common.Address, c *client.PublicClient) (*{{.ContractName}}, error) {
	cont, err := contract.NewContract(address, []byte(ContractABI), c)
	if err != nil {
		return nil, err
	}
	return &{{.ContractName}}{contract: cont, M: Methods}, nil
}

// MustNew creates a new {{.ContractName}} contract binding, panicking on error.
func MustNew(address common.Address, c *client.PublicClient) *{{.ContractName}} {
	cont, err := New(address, c)
	if err != nil {
		panic(err)
	}
	return cont
}

// Address returns the contract address.
func (c *{{.ContractName}}) Address() common.Address {
	return c.contract.Address()
}

// Contract returns the underlying contract instance.
func (c *{{.ContractName}}) Contract() *contract.Contract {
	return c.contract
}

// ABI returns the raw JSON ABI string.
func (c *{{.ContractName}}) ABI() string {
	return ContractABI
}

// ABIBytes returns the raw JSON ABI as bytes.
// This is the format expected by multicall and other ABI-consuming functions.
func (c *{{.ContractName}}) ABIBytes() []byte {
	return []byte(ContractABI)
}

// ParsedABI returns the pre-parsed ABI for efficient reuse.
// Useful for multicall operations to avoid re-parsing the ABI.
func (c *{{.ContractName}}) ParsedABI() (*abi.ABI, error) {
	return ParsedABI()
}

{{range .Functions}}
{{if .IsReadOnly}}
// {{.GoName}} calls the {{.Name}} function.
// Solidity: {{.Signature}}
func (c *{{$.ContractName}}) {{.GoName}}(ctx context.Context{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) ({{if eq (len .Outputs) 1}}{{(index .Outputs 0).GoType}}{{else if gt (len .Outputs) 1}}({{range $i, $o := .Outputs}}{{if $i}}, {{end}}{{$o.GoType}}{{end}}){{else}}error{{end}}, error) {
	result, err := c.contract.Read(ctx, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
	if err != nil {
		return {{if eq (len .Outputs) 1}}{{zeroValue (index .Outputs 0).GoType}}{{else if gt (len .Outputs) 1}}{{range $i, $o := .Outputs}}{{if $i}}, {{end}}{{zeroValue $o.GoType}}{{end}}{{end}}, err
	}
	{{if eq (len .Outputs) 0}}
	return nil
	{{else if eq (len .Outputs) 1}}
	return result[0].({{(index .Outputs 0).GoType}}), nil
	{{else}}
	return {{range $i, $o := .Outputs}}{{if $i}}, {{end}}result[{{$i}}].({{$o.GoType}}){{end}}, nil
	{{end}}
}
{{else}}
// Prepare{{.GoName}} prepares a transaction for the {{.Name}} function.
// Solidity: {{.Signature}}
func (c *{{$.ContractName}}) Prepare{{.GoName}}(ctx context.Context, opts contract.WriteOptions{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) (*types.Transaction, error) {
	return c.contract.PrepareTransaction(ctx, opts, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
}

// Estimate{{.GoName}} estimates gas for the {{.Name}} function.
func (c *{{$.ContractName}}) Estimate{{.GoName}}(ctx context.Context, opts contract.WriteOptions{{range .Inputs}}, {{.GoName}} {{.GoType}}{{end}}) (uint64, error) {
	return c.contract.EstimateGas(ctx, opts, "{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
}
{{end}}
{{end}}

{{if .HasEvents}}
// Event types
{{range .Events}}
// {{.GoName}}Event represents a {{.Name}} event.
type {{.GoName}}Event struct {
{{range .Inputs}}	{{.GoName}} {{.GoType}}
{{end}}}

{{end}}
{{end}}
`

// init adds zero value helper to template funcs.
func init() {
	templateFuncs["zeroValue"] = zeroValue
}

// zeroValue returns the zero value for a Go type.
func zeroValue(goType string) string {
	switch goType {
	case "bool":
		return "false"
	case "string":
		return `""`
	case "*big.Int":
		return "nil"
	case "common.Address":
		return "common.Address{}"
	case "common.Hash":
		return "common.Hash{}"
	case "[]byte":
		return "nil"
	case "uint8", "uint16", "uint32", "uint64", "int8", "int16", "int32", "int64":
		return "0"
	default:
		if goType[0] == '[' {
			// Array type
			return goType + "{}"
		}
		if goType[0] == '*' {
			return "nil"
		}
		return "nil"
	}
}

// eventTemplate is the template for event parsing helpers.
// nolint:unused // Reserved for future use
var _ = `
// Parse{{.GoName}} parses a {{.Name}} event from a log.
func (c *{{$.ContractName}}) Parse{{.GoName}}(log types.Log) (*{{.GoName}}Event, error) {
	event, err := c.contract.DecodeEvent("{{.Name}}", log.Topics, log.Data)
	if err != nil {
		return nil, err
	}
	
	ev := &{{.GoName}}Event{}
	{{range $i, $input := .Inputs}}
	if v, ok := event["{{$input.Name}}"]; ok {
		ev.{{$input.GoName}} = v.({{$input.GoType}})
	}
	{{end}}
	
	return ev, nil
}
`

// multicallTemplate generates multicall helper code.
// nolint:unused // Reserved for future use
var _ = `
// Multicall helpers for batching multiple calls.

// {{.ContractName}}Calls holds multiple call builders for the contract.
type {{.ContractName}}Calls struct {
	contract *{{.ContractName}}
	calls    [][]byte
}

// NewCalls creates a new call builder.
func (c *{{.ContractName}}) NewCalls() *{{.ContractName}}Calls {
	return &{{.ContractName}}Calls{contract: c}
}

{{range .Functions}}
{{if .IsReadOnly}}
// Add{{.GoName}} adds a {{.Name}} call to the batch.
func (b *{{$.ContractName}}Calls) Add{{.GoName}}({{range $i, $input := .Inputs}}{{if $i}}, {{end}}{{$input.GoName}} {{$input.GoType}}{{end}}) *{{$.ContractName}}Calls {
	data, _ := b.contract.contract.EncodeCall("{{.Name}}"{{range .Inputs}}, {{.GoName}}{{end}})
	b.calls = append(b.calls, data)
	return b
}
{{end}}
{{end}}

// Calldata returns all encoded calldata for the batch.
func (b *{{.ContractName}}Calls) Calldata() [][]byte {
	return b.calls
}
`
